#include <iostream>
#include <unordered_map>
#include <algorithm>
#include <limits>
#include <string>
#include <functional>
#include <stdlib.h>
#include <termios.h>
#include <unistd.h>
#include <vector>
#include <sstream>
#include <cstring>
#include <cctype>
#include <iomanip>
#include <deque>
#define ROXO "\033[38;5;201m"
#define VERDE "\033[38;5;46m"
#define AZUL "\033[38;5;39m"
#define VERMELHO "\033[38;5;196m"
#define LARANJA "\033[38;5;208m"
#define AMARELO "\033[38;5;220m"
#define CIANO "\033[38;5;51m"
#define PRETO "\033[38;5;232m"
#define BRANCO "\033[38;5;15m" 
#define CINZA "\033[38;5;249m"
#define RESET "\033[0m"
using namespace std;
typedef function<void()> FunctionWrapper;

void fpurge() { // Função p/ limpar o buffer do teclado
  cin.clear();
  cin.ignore(numeric_limits<streamsize>::max(), '\n');
}

size_t sizeMultibyt(const string &str) { // Função p/ descobrir o tamanho de uma string considerando caracteres multibyte (UTF-8)
  size_t tam = 0;
  for (auto it = str.begin(); it != str.end(); ) {
    if (*it == '\033') { // Verifica início de sequência de escape ANSI
      auto seq_end = find(it, str.end(), 'm');
      if (seq_end != str.end()) {
        it = seq_end + 1; // Pula a sequência de escape
        continue;
      }
    }
    unsigned char c = *it;
    if (c < 0x80) { ++it; } 
    else if (c < 0xE0) { it += 2; } 
    else if (c < 0xF0) { it += 3; } 
    else { it += 4; }
    tam++;
  }
  return tam;
}

auto centralBox(const vector<string> &textos, const string &corTexto = CIANO, const string &corBorda = AZUL) { // Função p/ centralizar texto em uma caixa
  size_t tam, tamMax = 0;
  vector<string> linhas;
  string textoFinal;
  for (const auto &texto : textos) { 
    istringstream stream(texto);
    string linha;
    while (getline(stream, linha)) { 
      linhas.push_back(linha);
      tam = sizeMultibyt(linha);
      if (tam > tamMax) { tamMax = tam; }
    }
  }
  textoFinal += corBorda + "╒";
  for (size_t i = 0; i < tamMax + 2; ++i) { 
    textoFinal += "═";
  }
  textoFinal += "╕\n" + string(RESET);
  for (const auto &linha : linhas) { 
    tam = sizeMultibyt(linha);
    size_t espacosEsquerda = (tamMax - tam) / 2;
    size_t espacosDireita = tamMax - tam - espacosEsquerda;
    textoFinal += corBorda + "│ " + RESET + corTexto + string(espacosEsquerda, ' ') + linha + string(espacosDireita, ' ') + corBorda + " │" + RESET + "\n";
  }  
  textoFinal += corBorda + "╘";
  for (size_t i = 0; i < tamMax + 2; ++i) { 
    textoFinal += "═";
  }
  textoFinal += "╛" + string(RESET); 
  return textoFinal;
}

auto alinBox(const vector<string> &textos) { // Função p/ alinhar caixas de texto
  size_t linMax = 0;
  string textoFinal;
  vector<vector<string>> caixaDeTextos;
  for (const auto &texto : textos) {  // Divide cada caixa de texto em linhas
    vector<string> linhasCaixa;
    istringstream stream(texto);
    string linha;
    while (getline(stream, linha)) {
      linhasCaixa.push_back(linha);
    }
    caixaDeTextos.push_back(linhasCaixa);
    if (linhasCaixa.size() > linMax) {
      linMax = linhasCaixa.size();
    }
  }
  for (size_t i = 0; i < linMax; ++i) { // Alinha as linhas das duas strings lado a lado
    for (const auto &caixas : caixaDeTextos) {
      if (i < caixas.size()) { 
        textoFinal += caixas[i]; 
      } 
        else { 
          textoFinal += string(caixas[0].size(), ' '); 
        }
    }
    if (i < linMax - 1) { 
      textoFinal += "\n"; 
    }
  }
  return textoFinal;
}

void limpTela() { // Função p/ limpar a tela
  string lixo;
  cout << "\nAperte \033[38;5;51m[ENTER]\033[0m p/ continuar...";
  getline(cin, lixo);
  if (system("clear") && system("cls")) {
    cout << "\n\033[38;5;196m[Erro ao limpar a tela!]\033[0m" << endl;
    exit(1);
  }
}

bool simOuNao(const string &msg) { // Função p/ confirmar ação
  char resposta;
  do {
    limpTela();
    cout << centralBox({msg,
      "╔═══════════════════════════╗",
      "║      ▷ CONFIRMAÇÃO ◁      ║",
      "╠═════════════╦═════════════╣",
      "║     SIM     ║     NÃO     ║",
      "╚═════════════╩═════════════╝"}) << endl;
    cout << "⌨ : ";
    cin >> resposta;
    fpurge();
    resposta = tolower(resposta);
    if (resposta != 's' && resposta != 'n') { cout << "\n" + centralBox({"▷ Resposta inválida! Tente novamente... ◁"}, VERMELHO) << endl; }
  } while (resposta != 's' && resposta != 'n');
  return (resposta == 's');
}

bool verAcentos(char c) { // Função p/ verificar caracteres acentuados
  char c_acentos[] = "áéíóúàèìòùâêîôûãõäëïöüçÁÉÍÓÚÀÈÌÒÙÂÊÎÔÛÃÕÄËÏÖÜÇ";
  for (int i = 0; i < strlen(c_acentos); i++) {
    if (c == c_acentos[i]) {
      return true;
    }
  }
  return false;
}

bool verStr(const string str) { // Função p/ verificar se um nome é válido
  int espaco = 1;
  for (int i = 0; str[i] != '\0'; i++) {
    if (!isspace(str[i])) {
      espaco = 0;
      break;
    }
  }
  if (espaco) {
    return false;
  }
  for (int i = 0; str[i] != '\0'; i++) {
    if (!isalpha(str[i]) && !isspace(str[i]) && !verAcentos(str[i])) {
      return false;
    }
  }
  return true;
}

