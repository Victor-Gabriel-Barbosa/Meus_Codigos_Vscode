FUN√á√ïES *C*:

// Bibliotecas +√∫teis:
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdio_ext.h>
#include <locale.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <math.h>
#include <unistd.h>

srand(time(NULL));

// Remover caracter de nova linha: 
palavra1[strlen(palavra1)-1] = '\0';

// Remover caracter de nova linha: 
if ((pos = strchr(validacao, '\n')) != NULL)
                *pos = '\0';

// *Fun√ß√µes interessantes: 
}+> atoi(*entrada*) }> Transforma STRING em INT (Ps.: se n√£o houver n√∫mero ela retorna 0);

}+> isdigit(*entrada*) }> Verifica se um CARACTER √© um n√∫mero [retorna 1 se for um n√∫mero e 0 caso n√£o seja];

}+> isalpha(*entrada*) }>  Verifica se uma STRING cont√©m apenas CARACTERES [retorna 1 se verdadeiro e 0 se falso]
(Ps.: Essa fun√ß√£o n√£o √© adequada para verificar CARACTERES acentuados, 
pois alguns compiladores os consideram como sendo STRINGS. 
Nesse caso √© aconselhado criar uma fun√ß√£o pr√≥pria...);

}+> __fpurge(stdin) }> Limpa Buffer de Entrada (COMPILADOR LINUX)

}+> fflush(stdin) }> Limpa Buffer de Entrada (COMPILADOR WINDOWS)

}+> strstr(*entrada*, CARACTER/STRING) }> Verifica se o CARACTER/STRING est√° presente em qualquer posi√ß√£o de *entrada*
[retorna um ponteiro se for verdadeiro e NULL caso n√£o seja]

}+> strcmp(*entrada*, STRING) }>  Verifica se a STRING √© igual a *entrada*
[retorna 0 se for igual, um valor menor do que 0 se a *entrada* for menor do que a STRING e um valor maior do que 0 se a *entrada* for maior do que a STRING]

}+> strchr(STRING, CARACTER) }> Verfica se um CARACTER est√° dentro de uma STRING [retorna NULL se n√£o encontrar o CARACTER e um ponteiro se encontrar]

}+> strpbrk(STRING, STRING) }> Verfica se algum CARACTER de uma STRING est√° dentro de uma outra STRING [retorna NULL se n√£o encontrar a STRING e um ponteiro se encontrar]

}+> strcase+str/cmp+... }> Ignora acentos e letras mai√∫sculas ou min√∫sculas

void limpaTela() { // [FUN√á√ÉO DE LIMPAR TELA]
  printf("\033[0m\nAperte [\033[38;5;39mENTER\033[0m] para continuar...");
  getchar();
  __fpurge(stdin);
  system("clear");
}

void barra(char *ini, char *fin) {
  printf("%s\033[38;5;51m<>\033[0m==============\033[38;5;201m<>\033[0m==============\033[38;5;51m<>\033[0m%s", ini, fin);
}

int simNao() { // [FUN√á√ÉO DE SIM OU N√ÉO]
  int opcao;
  do { // [LOOP P/ VALIDA√á√ÉO]
    limpa_tela();
    opcao = -1;
    barra("\n", "\n");
    printf("\033[38;5;201m[TEM CERTEZA?]\033[0m");
    barra("\n", "\n");
    printf("|[\033[38;5;51m1\033[0m]> Sim\n");
    printf("|[\033[38;5;51m0\033[0m]> N√£o");
    barra("\n", "\n");
    printf("Op√ß√£o\033[38;5;51m: ");
    scanf("%d", &opcao);
    __fpurge(stdin);
    barra("", "\n");
    if (opcao < 0 || opcao > 1) {
      printf("\n\033[38;5;196m[Op√ß√£o inv√°lida! Tente novamente...]\033[0m\n");
    }
  } while (opcao < 0 || opcao > 1);
  return opcao;
}

int strlenExt(char *str) { // [FUN√á√ÉO DE VERIFICAR TAMANHO DE STRING "MELHORADA"]
  int i, tam = 0, ASCII = 0;
  for (i = 0; str[i] != '\0'; i++) {
    if (str[i] == '\033') {
      ASCII = 1;
    } 
      else if (ASCII && str[i] == 'm') {
        ASCII = 0;
      } 
        else if (!ASCII) {
          tam++;
        }
  }
  return tam;
}

void central(char *format, ...) { // [FUN√á√ÉO DE CENTRALIZAR TEXTO]
  char str[256];
  va_list args;
  va_start(args, format);
  vsprintf(str, format, args);
  va_end(args);
  int i, espacos, tam = strlen_ext(str);
  int linha = strlen_ext("\033[38;5;51m<>\033[0m==============\033[38;5;201m<>\033[0m==============\033[38;5;51m<>\033[0m");
  espacos = (linha - tam) / 2;
  for (int i = 0; i < espacos; i++) {
    printf(" ");
  }
  printf("%s", str);
}

int verAcentos(char c) { // [FUN√á√ÉO DE VERIFICAR CARACTERES ACCENTUADOS]
  char c_acentos[] = "√°√©√≠√≥√∫√†√®√¨√≤√π√¢√™√Æ√¥√ª√£√µ√§√´√Ø√∂√º√ß√Å√â√ç√ì√ö√Ä√à√å√í√ô√Ç√ä√é√î√õ√É√ï√Ñ√ã√è√ñ√ú√á";
  for (int i = 0; i < strlen(c_acentos); i++) {
    if (c == c_acentos[i]) {
      return 1;
    }
  }
  return 0;
}

int verStr(char *str) { // [FUN√á√ÉO DE VERIFICAR SE UM NOME √â V√ÅLIDO]
  int espaco = 1;
  for (int i = 0; str[i] != '\0'; i++) {
    if (!isspace(str[i])) {
      espaco = 0;
      break;
    }
  }
  if (espaco) {
    return 0;
  }
  for (int i = 0; str[i] != '\0'; i++) {
    if (!isalpha(str[i]) && !isspace(str[i]) && !ver_acentos(str[i])) {
      return 0;
    }
  }
  return 1;
}

void exibHP(int hp_atual, int hp_maximo) { // [FUN√á√ÉO DE EXIBIR BARRA DE HP]
  int i, tam_barra = 20; 
  int qtd_simb = (hp_atual * tam_barra) / hp_maximo; 
  printf("HP: ");
  for (i = 0; i < qtd_simb; i++) {
    printf("\033[38;5;46m=\033[0m"); 
  }
  for (i = qtd_simb; i < tam_barra; i++) {
    printf(" ");
  }
  printf(" %d/%d\n", hp_atual, hp_maximo);
}

int verStr(char *str) { // [FUN√á√ÉO DE VERIFICAR STRING]
  char letras_mai[] = "ABC√áDEFGHIJKLMNOPQRSTUVWXYZ√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ò√ô√ö√õ√ú√ù≈∏";
  char letras_min[] = "abc√ßdefghijklmnopqrstuvwxyz√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∏√π√∫√ª√º√Ω√ø";
  char temp[strlen(str)];
  sprintf(temp, "%c", str[0]);
  if (strstr(letras_mai, temp)) {
    for (int i = 0; str[i] != '\0'; i++) {
      sprintf(temp, "%c", str[i]);
      if (!strstr(letras_mai, temp) && !strstr(letras_min, temp)) {
        return 0;
      }
    }
  }
    else {
      return 0;
    }
  return 1;
}

/* ALTERA√á√îES VISUAIS DE TEXTO: */
// Formato:
printf("\033[1m"); // Negrito
printf("\033[3m"); // It√°lico
printf("%-10s", "texto"); // Alinhar √† esquerda
printf("%10s", "texto"); // Alinhar √† direita
printf("\033[0m"); // Sublinhar

// Cores B√°sicas:
printf("\033[0;31m"); // Vermelho
printf("\033[0;32m"); // Verde
printf("\033[0;33m"); // Amarelo
printf("\033[0;34m"); // Azul
printf("\033[0;35m"); // Magenta
printf("\033[0;36m"); // Ciano
printf("\033[0m");    // Reset

// Cores B√°sicas (Vibrantes):
\033[38;5;196m // Vermelho
\033[38;5;46m // Verde
\033[38;5;39m // Azul
\033[38;5;51m // Ciano
\033[38;5;201m // Magenta
\033[38;5;220m // Amarelo

\033[38;5;214m // Laranja
\033[38;5;208m // Laranja Escuro
\033[38;5;118m // Verde Escuro
\033[38;5;202m // Vermelho Escuro
\033[38;5;93m // Roxo Escuro
\033[38;5;159m // Azul Claro
\033[38;5;205m // Rosa

// Definir Cores:
#define red "\033[0;31m"
#define gre "\033[0;32m"
#define yel "\033[0;33m"
#define blu "\033[0;34m"
#define mag "\033[0;35m"
#define cia "\033[0;36m"
#define res "\033[0m"

// EXTRAS:
\n: Nova linha - Move o cursor para o in√≠cio da pr√≥xima linha;
\r: Retorno de carro - Move o cursor para o in√≠cio da linha atual;
\t: Tabula√ß√£o - Move o cursor para a pr√≥xima posi√ß√£o de tabula√ß√£o;
\b: Retrocesso - Move o cursor uma posi√ß√£o para tr√°s;
\f: Alimenta√ß√£o de formul√°rio - Move o cursor para o in√≠cio da pr√≥xima p√°gina;
\v: Tabula√ß√£o vertical - Move o cursor para a pr√≥xima linha na mesma posi√ß√£o horizontal;
\\: Barra invertida - Representa uma barra invertida literal (\);
\': Aspas simples - Representa uma aspas simples literal (');
\": Aspas duplas - Representa uma aspas duplas literal (");
\?: Ponto de interroga√ß√£o - Representa um ponto de interroga√ß√£o literal (?);
\0: Nulo - Representa o caractere nulo, que tem valor zero;
\x seguido por um n√∫mero hexadecimal para representar qualquer caractere pelo seu valor ASCII.

‚ö†Ô∏é‚öîÔ∏è‚öîÔ∏éüõ°Ô∏è‚ô¶Ô∏é‚ù§Ô∏é‚ùáÔ∏é‚ú¥Ô∏é‚öúÔ∏é